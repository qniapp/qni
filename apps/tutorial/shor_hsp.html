---
layout: page
section: ショアの因数分解
title: 別問題に帰着する
description: 因数分解を反復周期 (位数) 発見問題として解く
prev: 量子位相推定の出力
prev_url: ./qpe_output.html
next: \(a^xmod(N)\) の計算
next_url: shor_fx.html
---

<p>
  ショアの因数分解アルゴリズムは、量子コンピュータが得意とする計算のうち最も有名なものの 1 つです。
  <a href="./">はじめに</a
  >で述べたように、因数分解が高速にできると、公開鍵暗号を現実的な時間のうちに解くことができます。
  公開鍵暗号はインターネット通信やビットコイン技術等の拠り所であるため、これが解けてしまうというインパクトは相当なものです。
</p>

<p>
  ショアの因数分解アルゴリズムはどれほど速いのでしょうか。
  古典の因数分解アルゴリズムである「一般数体ふるい法」の実行時間は、因数分解したい数が大きくなるにつれて指数関数的に増えます。
  一方でショアのアルゴリズムは、多項式時間に留まります。 分かりやすく具体的な値で言うと、1024
  ビットの整数を因数分解するのに必要な計算量は、古典コンピュータ (一般数体ふるい法) で
  \(O(10^{278})\) です。 これに対して、ショアのアルゴリズムは \(O(10^{61})\) となり、\(10^{278}
  \rightarrow 10^{61}\) と計算量を大幅に減らせます。
</p>

<h2>因数分解を別問題として解く</h2>

<p>
  因数分解のような整数問題の多くは、より解きやすい別問題に帰着させて解くことができます。
  ショアのアルゴリズムでは、因数分解を次の別問題に帰着させます。
</p>

<div class="border-l-4 border-blue-400 bg-blue-50 px-4 py-1 md:mr-auto md:w-7/12">
  <p>
    <strong>反復周期 (位数とも呼ぶ) の発見問題</strong>
  </p>

  <p>
    \(N\) を因数分解したい整数とする。 このとき、ある整数 \(a\) (\(a \lt N\), かつ \(a\) と \(N\)
    は共通の因数を持たない) について、整数 \(x\) を変数とする次の関数を考える。
  </p>

  <p class="flex justify-center">
    \(f(x) = a^x mod(N) \hspace{16pt} (X mod(Y) は X を Y で割った余りを表す)\)
  </p>

  <p>これは周期関数となり、その反復周期 \(r\) から \(N\) の因数を求められる。</p>
</div>

<p>
  分かりやすくするために、\(a\) や \(N\) に具体的な値を入れて関数 \(f(x)\)
  がどう動くか見ていきましょう。 因数分解したい数 \(N\) を 15 とします。 \(a\) は \(N\) より小さく
  \(N\) と共通の因数を持たなければ何でも良いので、ここでは 2 とします。すると、\(f(x)\)
  は次のように書き直せます。
</p>

<p class="flex justify-center">\(f(x) = 2^x mod(15)\)</p>

<figure>
  <img src="./images/shor_mod15.png" class="h-auto w-full" />
</figure>

<p>
  グラフから一目瞭然のとおり、この関数は周期関数になっており、反復周期 \(r\) は 4 です。x が 4
  増えるごとに、まったく同じ形の波が現れるからです。
</p>

<p>反復周期 \(r = 4\) が求まれば、\(N\) の因数はそれぞれ次の単純な計算で求まります。</p>

<ul>
  <li>\(gcd(N, a^{r/2} + 1)\)</li>
  <li>\(gcd(N, a^{r/2} - 1)\)</li>
</ul>

<p>
  ここで出てくる \(gcd\) とは最大公約数 (greatest common divisor)
  の略で、古典コンピュータでも高速に計算できる処理です。 たとえば \(N = 15\)
  の場合で具体的に計算してみると、\(a = 2\), 周期 \(r = 4\) だったので、
</p>

<ul>
  <li>\(gcd(N, a^{r/2} + 1) = gcd(15, 2^{4/2} + 1) = gcd(15, 5) = 5\)</li>
  <li>\(gcd(N, a^{r/2} - 1) = gcd(15, a^{4/2} - 1) = gcd(15, 3) = 3\)</li>
</ul>

<p>となり、たしかに \(15 = 5 \times 3\) が求まりました!</p>

<div class="my-5 border-l-4 border-blue-400 bg-blue-50 p-4 md:mr-auto md:w-7/12">
  <strong>注意点:</strong> 周期 \(r\) が偶数の場合のみ gcd が計算できることに注意してください。 N=15
  の場合、\(a\) を 2 とすると偶数の周期 \(r = 4\) が求まります。 選ぶ \(a\) の値によっては \(r\)
  が偶数になりません。 また \(r\) が偶数であっても、gcd の結果が \(N\)
  の因数にならない場合があります (因数かどうかは、積が \(N\)
  になるかどうかを調べるだけで簡単にチェックできます)。
  このため実際のショアのアルゴリズムでは、\(r\) が偶数になり、かつ正しい因数が求まるまで、\(a\)
  をランダムに選び計算を繰り返します。
</div>

<h2>古典コンピュータでショアのアルゴリズムを実行すると?</h2>

<p>
  もしショアのアルゴリズムを古典コンピュータで実行すると、計算量はどうなるでしょうか。
  ショアのアルゴリズムの核心は、f(x) の反復周期 r を求める部分でした。
  古典コンピュータで周期を求めるには、f(x) の同じ値 (1, 2, 4, 8 など)
  が出てくる間隔を求めることで周期が求まります。 これは、f(x) の 1 つの周期には同じ値が 1
  度しか出てこないことが数学的に分かっているためです。 これを使えばたとえば、x を 1
  つずつ増やしながら f(x) がふたたび 1 となる点の x を求めることで r も求まります。
</p>

<figure>
  <img src="./images/shor_mod15_r.png" class="h-auto w-full" />
</figure>

<p>
  問題は、N のビット数が増えるにつれて反復周期 r が指数関数的に増えることです。
  このため、古典コンピュータではショアのアルゴリズムを使ってもやはり指数時間かかってしまいます。
</p>

<h2>まとめ</h2>

<p>
  ショアの因数分解アルゴリズムは、関数 \(f(x) = a^x mod(N)\)
  の反復周期を求めるという別問題を解くことで因数を求めます。
  この周期を求める計算は、古典コンピュータでは指数時間が必要なため、量子コンピュータを使います。
  求めた周期を使って古典コンピュータで gcd を計算することで、\(N\) の因数が求まります。
</p>
