---
layout: page
section: 重ね合わせ上での演算
title: 足し算回路
description: 任意の数を足す
prev: デクリメント回路
prev_url: ./decrement_circuit.html
---

<p>
  これまでは、+1 や -1 のように定数を足す回路を見てきました。
  これだけではほとんど何もできずつまらないので、任意の数を足し合わせる回路を考えてみましょう。
</p>

<p>
  足し算というと \(a + b = c\)
  という式をすぐに思い付きますが、これは可逆な回路として実装できません。 なぜかと言うと、\(a\) と
  \(b\) から \(c\) を求めることはできても、逆に \(c\) から \(a\) と \(b\)
  を一意に求めることができないからです。 つまり足し算 \(a + b = c\)
  に逆演算が存在しないことになり、よって可逆な回路としては実装できない (=
  重ね合わせをそのまま出力できない) ことになります。
</p>

<p>
  そのかわりに、\(a \mathrel{+}= b\) という回路を実装します。
  これはプログラミングによく出てくる演算子で、\(a\) に \(a + b\) の結果を代入することを意味します。
  もし \(a\) を元の値に戻したくなった場合、\(a \mathrel{-}= b\) (\(a\) に \(a - b\) の結果を代入)
  という逆演算が存在するので、逆回路も問題なく実装できそうです。
</p>

<h2>足し算回路</h2>

<p>
  以下が \(a \mathrel{+}= b\) を実装した量子回路です。 \(a\) に 1 と 5
  を重ね合わせた値をセットし、\(b\) には 3 をセットします。 \(a \mathrel{+}= b\) を実行すると \(a\)
  には 4 と 8 を重ね合わせた値が残ります。 \(b\) は変化しません。
</p>

<div class="relative mb-10 rounded-md bg-neutral-50">
  <div class="overflow-scroll p-8">
    <quantum-simulator class="flex flex-col" data-service-worker="/serviceworker.js">
      <circuit-editor>
        <div
          class="absolute top-px right-px z-40 rounded-bl-2xl rounded-tr-md bg-white drop-shadow-xl"
        >
          <inspector-button
            data-target="circuit-editor.inspectorButton"
            class="inline-block h-10 w-10 p-1"
          >
            <div
              class="flex h-full w-full items-center justify-center rounded-xl hover:bg-gray-200"
            >
              {% include mixer_horizontal.svg class="h-4 w-4 text-gray-700" %}
            </div>
          </inspector-button>
        </div>

        <quantum-circuit
          class="mb-10"
          data-target="quantum-simulator.circuit circuit-editor.circuit"
          data-min-wire-count="1"
          data-max-wire-count="1"
          data-min-step-count="8"
          data-json='{"cols":[["{a=1と5の重ね合わせ"],["|0>","|0>","|0>","|0>"],["X"],[1,1,"H"],["}"],[1],["{b=3"],[1,1,1,1,"|0>","|0>","|0>"],[1,1,1,1,"X","X"],["}"],[1],["{a+=b (a=4と8の重ね合わせ)"],["•","•","•","X","•"],["•","•","X",1,"•"],["•","X",1,1,"•"],["X",1,1,1,"•"],[1,"•","•","X",1,"•"],[1,"•","X",1,1,"•"],[1,"X",1,1,1,"•"],[1,1,"•","X",1,1,"•"],[1,1,"X",1,1,1,"•"],["}"],[1]]}'
        >
        </quantum-circuit>

        <circle-notation
          id="circle-notation"
          data-target="quantum-simulator.circleNotation"
          data-qubit-circle-popup-template-id="circle-notation-popup"
          class="border-swan z-40 flex w-min flex-row justify-center rounded-xl border-2 border-b-4 bg-white"
          data-padding-X="16"
          data-padding-Y="20"
        >
        </circle-notation>
      </circuit-editor>

      <run-circuit-button
        class="absolute bottom-0 right-0 z-40 mr-6 mb-8 hidden h-16 w-16 rounded-full bg-purple-500 text-white drop-shadow-md md:inline-block"
        data-targets="quantum-simulator.runCircuitButtons"
      ></run-circuit-button>
    </quantum-simulator>
  </div>
</div>

<p>
  インクリメントやデクリメント回路と大きく違う点は、b をセットするブロック (\(b = 3\))
  が存在することです。 \(a\) の値は 7 量子ビットの下位 4 ビット、\(b\) の値は上位 3
  ビットを使って表されていることに注意してください。 ここで \(b\) の値は 3 (二進数で 011)
  にセットされており、また計算中は \(b\) の値はずっと変わらず 011 のままなので、\(b = 3\)
  のブロック以降の円表示では、上位 3 ビットが必ず 011 となります。
</p>

<p>
  このため、計算結果の見方には注意が必要です。 計算結果の \(a\) の値は 4 と 8 (二進数で 0100 と
  1000) の重ね合わせになっているはずですが、円表示で見ると 52 と 56 (二進数で 0110100 と 0111000)
  になっています。 これは計算結果に \(b\) の値 3 (二進数で 011)
  もあわせて表示されているためで、これが上位 3 ビットなので二進数では 0110000 (十進数で 48)
  が足し合わされています。 そこで \(a\) の値だけを読み取るには上位 3 ビットの 011
  を無視するか、十進数で 48 を引いてやる必要があります。
</p>

<h2>a += b 回路の仕組み</h2>

<p>この回路はやや複雑に見えますが、やっていることは次の 2 つの繰り返しです。</p>

<ul>
  <li>\(a\) と \(b\) の対応するビット同士で、一番下のビットから順に二進数の足し算をする</li>
  <li>足し算で 1 + 1 が起こった場合、1 つ上のビットに 1 繰り上げる</li>
</ul>

<p>それぞれの計算をどの部分で行っているか、\(a \mathrel{+}= b\) のブロックを見ていきましょう。</p>

<p>
  \(a\) と \(b\) のビット同士の足し算では、それぞれのビットの値によって次の 4 パターンが起こります。
  表をよく見ると、\(a\) と \(b\) どちらかのビットだけが 1 の時のみ、\(a + b\) は 1 になります。
  論理演算に詳しい人なら、これは XOR (排他的論理和) と同じ、ということに気付くでしょう。
</p>

<div class="my-5 md:mr-auto md:w-7/12">
  <table>
    <thead>
      <tr>
        <th>a のビット</th>
        <th>b のビット</th>
        <th>a + b</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>1</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>0 (1 繰り上げ)</td>
      </tr>
    </tbody>
  </table>
</div>

<p>
  \(a\) と \(b\) の再下位ビット同士の足し算を計算している部分は、下の回路で左から 4 番目のステップの
  CNOT です。 \(b\) の再下位ビットを <control-gate class="operation-xs"></control-gate> とし、\(a\)
  の再下位ビットに <x-gate class="operation-xs"></x-gate> を適用しています。
  これを論理演算の用語で言えば、「CNOT は XOR の計算を (重ね合わせに対しても)
  実行できる」と言えます。
</p>

<div class="my-5 md:mr-auto md:w-7/12">
  <quantum-circuit
    data-max-wire-count="7"
    data-json='{"cols":[["{a += b"],["•","•","•","X","•"],["•","•","X",1,"•"],["•","X",1,1,"•"],["X",1,1,1,"•"],[1,"•","•","X",1,"•"],[1,"•","X",1,1,"•"],[1,"X",1,1,1,"•"],[1,1,"•","X",1,1,"•"],[1,1,"X",1,1,1,"•"],["}"],[1]]}'
  >
  </quantum-circuit>
</div>

<p>
  再下位ビットの足し算で繰り上がった 1 をセットする部分は、左から 3 番目の CCNOT です。 \(a\)
  の再下位ビットと \(b\) の再下位ビット \(b\) を
  <control-gate class="operation-xs"></control-gate> とし、両方が 1 だった場合に繰り上がるビット (a
  の 2 ビット目) に <x-gate class="operation-xs"></x-gate> を適用します。
</p>

<p>
  以上の足し算と繰り上がりをビットごとに繰り返し行うことで、\(a \mathrel{+}= b\)
  の回路ができあがります。
</p>

<h2>重ね合わせに重ね合わせを足す</h2>

<p>
  先ほどの例では \(b\) に 3 をセットしていましたが、これを重ね合わせにするとどうなるでしょうか？
  たとえば \(a\) を 1 と 5 の重ね合わせ、\(b\) を 2 と 6
  の組合わせにして足すと、和はどんな重ね合わせになるでしょう？
</p>

<p>1 と 5 の重ね合わせ + 2 と 6 の重ね合わせ = ???</p>

<div class="relative mb-10 rounded-md bg-neutral-50">
  <div class="overflow-scroll p-8">
    <quantum-simulator class="flex flex-col" data-service-worker="/serviceworker.js">
      <circuit-editor>
        <div
          class="absolute top-px right-px z-40 rounded-bl-2xl rounded-tr-md bg-white drop-shadow-xl"
        >
          <inspector-button
            data-target="circuit-editor.inspectorButton"
            class="inline-block h-10 w-10 p-1"
          >
            <div
              class="flex h-full w-full items-center justify-center rounded-xl hover:bg-gray-200"
            >
              {% include mixer_horizontal.svg class="h-4 w-4 text-gray-700" %}
            </div>
          </inspector-button>
        </div>

        <quantum-circuit
          class="mb-10"
          data-target="quantum-simulator.circuit circuit-editor.circuit"
          data-min-wire-count="1"
          data-max-wire-count="1"
          data-min-step-count="8"
          data-json='{"cols":[["{a=1と5の重ね合わせ"],["|0>","|0>","|0>","|0>"],["X"],[1,1,"H"],["}"],[1],["{b=2と6の重ね合わせ"],[1,1,1,1,"|0>","|0>","|0>"],[1,1,1,1,1,"X"],[1,1,1,1,1,1,"H"],["}"],[1],["{a+=b=???"],["•","•","•","X","•"],["•","•","X",1,"•"],["•","X",1,1,"•"],["X",1,1,1,"•"],[1,"•","•","X",1,"•"],[1,"•","X",1,1,"•"],[1,"X",1,1,1,"•"],[1,1,"•","X",1,1,"•"],[1,1,"X",1,1,1,"•"],["}"],[1]]}'
        >
        </quantum-circuit>

        <circle-notation
          id="circle-notation"
          data-target="quantum-simulator.circleNotation"
          data-qubit-circle-popup-template-id="circle-notation-popup"
          class="border-swan z-40 flex w-min flex-row justify-center rounded-xl border-2 border-b-4 bg-white"
          data-padding-X="16"
          data-padding-Y="20"
        >
        </circle-notation>
      </circuit-editor>

      <run-circuit-button
        class="absolute bottom-0 right-0 z-40 mr-6 mb-8 hidden h-16 w-16 rounded-full bg-purple-500 text-white drop-shadow-md md:inline-block"
        data-targets="quantum-simulator.runCircuitButtons"
      ></run-circuit-button>
    </quantum-simulator>
  </div>
</div>

<p>
  上の回路の実行結果を見ると、35 (二進数で 0100011)、39 (二進数で 0100111)、103 (二進数で
  1100111)、107 (二進数で 1101011) の重ね合わせが出力されています。 ここで \(b\) の値は 2 と 6
  の重ね合わせ (それぞれ二進数で 010 と 110) なので、これら上位 3 ビットを無視すると、 出力結果は
  0011, 0111, 0111, 1011 であり、ダブった値 0111 を除くと 3 通りになります。 これは十進数で 3 (= 1 +
  2), 7 (= 1 + 6 または 5 + 2), 11 (= 5 + 6)
  となり、重ね合わせの和がすべての通りについて出ていることが分かります。
</p>

{% include operation_menu.html %} {% include operation_inspector_template.html %} {% include
circle_notation_popup.html %}
