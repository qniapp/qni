---
layout: page
section: QPU 命令その 1
title: CPU 命令との違い
description: 量子コンピュータ版 論理演算
prev: 状態ベクトル表示
prev_url: ./circle_notation.html
next: X ゲート (量子 NOT)
next_url: ./x_gate.html
---

<p>
  QPU 命令は、CPU で実行される AND や NOT, OR といった命令 (論理演算) の量子ビット版です。 QPU
  命令と CPU 命令には、次の大きな違いがあります。
</p>

<h2>QPU 命令は重ね合わせ状態に作用できる</h2>

<p>
  CPU 論理演算は 0 または 1 のみを入力・出力します。 0 と 1 は古典 1 ビットで表せる値のすべてです。
</p>

<figure>
  <img src="./images/logic_gates_and_not.png" class="h-auto w-full" />
</figure>

<p>
  一方で QPU 命令は量子ビットを入出力します。 量子ビットは 0 と 1 だけでなく、0 と 1 の確率
  (重ね合わせ) を持つことができ、また位相という角度データも持つのでした。 QPU
  命令は量子ビットの持つ確率と位相の両方に作用します。
</p>

<div class="mt-5 mb-8 flex justify-center md:mr-auto md:w-7/12">
  <div class="mt-4 mb-2 flex flex-row items-center space-x-1">
    <div class="flex flex-row">
      {{ '-0.20015 + 0.44444i' | qubit_circle: 0, 'lg' }} {{ '0.67819 - 0.54997i' | qubit_circle: 1,
      'lg' }}
    </div>

    <div class="flex flex-row items-center">
      {% include minus.svg class="h-6 w-6 fill-current text-neutral-400" %}
      <span class="whitespace-nowrap rounded bg-emerald-500 p-2 text-sm text-white">QPU命令</span>
      {% include arrow_right.svg class="h-6 w-6 fill-current text-neutral-400" %}
    </div>

    <div class="flex flex-row">
      {{ '0.67819 - 0.54997i' | qubit_circle: 0, 'lg' }} {{ '-0.20015 + 0.44444i' | qubit_circle: 1,
      'lg' }}
    </div>
  </div>
</div>

<h2>QPU 命令の大部分は逆方向の命令 (逆演算) を持つ</h2>

<p>
  AND などの CPU 命令では、出力の 1 ビットから入力の 2 ビットを知ることはできません。 たとえば、AND
  の出力が 0 だった場合には、入力は 00/01/10 の 3 通りで、どれか 1 つに特定することはできません。
  これを「AND は非可逆である」と言います。
</p>

<p>
  一方でほとんどの QPU 命令は可逆です。 つまりある QPU 命令に対応する逆命令 (逆演算)
  を適用することで、出力の量子ビットから元々の入力された量子ビットを得ることができます
</p>

<div class="my-5 flex overflow-x-auto">
  <div class="mt-4 mb-2 flex flex-row items-center space-x-1">
    <div class="flex flex-row">
      {{ '-0.20015 + 0.44444i' | qubit_circle: 0, 'lg' }} {{ '0.67819 - 0.54997i' | qubit_circle: 1,
      'lg' }}
    </div>

    <div class="flex flex-row items-center">
      {% include minus.svg class="h-4 w-4 fill-current text-neutral-400" %}
      <span class="whitespace-nowrap rounded bg-emerald-500 p-2 text-xs text-white">命令</span>
      {% include arrow_right.svg class="h-4 w-4 fill-current text-neutral-400" %}
    </div>

    <div class="flex flex-row">
      {{ '0.67819 - 0.54997i' | qubit_circle: 0, 'lg' }} {{ '-0.20015 + 0.44444i' | qubit_circle: 1,
      'lg' }}
    </div>

    <div class="flex flex-row items-center">
      {% include minus.svg class="h-4 w-4 fill-current text-neutral-400" %}
      <span class="whitespace-nowrap rounded bg-emerald-500 p-2 text-xs text-white">逆演算</span>
      {% include arrow_right.svg class="h-4 w-4 fill-current text-neutral-400" %}
    </div>

    <div class="flex flex-row">
      {{ '0.67819 - 0.54997i' | qubit_circle: 1, 'lg' }} {{ '-0.20015 + 0.44444i' | qubit_circle: 0,
      'lg' }}
    </div>
  </div>
</div>

<p>後に詳しく見ていきますが、逆演算は量子プログラミングでひんぱんに使うテクニックの 1 つです。</p>

<p>
  たとえば量子ビット同士をもつれさせるいくつかの QPU
  命令の後に逆演算を施すと、もつれた量子ビットを元通りに戻すことができます。
  この量子ビットをもつれさせる/ほどくという操作は、量子プログラミングの基本的なテクニックです{%
  nmargin_note disentangle %}<a href="./entanglement.html">量子もつれ</a>と<a
    href="./disentangle.html"
    >もつれをほどく</a
  >で説明しています。{% endnmargin_note %}。
</p>

<p>
  逆演算は実行中にぐちゃぐちゃになった量子ビットの状態をリセットして、元の初期状態に戻すのにも使えます。
  たとえばある処理内の一時変数として使った量子ビットを、処理が終了した後リセットして 0
  に戻し、再利用する場合などです{% nmargin_note uncomputation %}<a
    href="./multiplication_circuit.html"
    >かけ算回路</a
  >で説明しています。{% endnmargin_note %}。
</p>

<p>これらのテクニックの基本となる、代表的な QPU 命令と逆演算を具体的に見ていきましょう。</p>

<template id="circle-notation-popup">
  <ul class="list-none">
    <li>
      確率:
      <span class="probability text-eel font-mono font-bold"></span>
    </li>
    <li>
      位相:
      <span class="phase text-eel font-mono font-bold"></span>
    </li>
  </ul>
</template>

{% include operation_menu.html %} {% include operation_inspector_template.html %}
