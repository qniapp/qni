---
---

<!DOCTYPE html>
<html lang="">
  <head>
    <title>量子コンピュータで何が速くなる？</title>

    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <title>Untitled</title>
    <meta name="description" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <!-- Place favicon.ico in the root directory -->

    <script type="module" src="./application.js" defer></script>
    <link href="./application.css" rel="stylesheet" />

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
  </head>
  <body>
    <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
      <div class="mx-auto py-10">
        <div class="pb-16">
          <div>
            <h1 class="inline-block text-3xl font-extrabold text-gray-900 tracking-tight">
              量子コンピュータで何が速くなる？
            </h1>
          </div>
          <p class="my-1 text-lg text-gray-500">量子コンピュータの得意分野と制約を知る</p>
        </div>

        <p class="pb-10">
          今回は、量子コンピュータで何が速くなるのか、そしてさらに重要なことですが、量子コンピュータに課せられるいくかの制約を説明します。
        </p>

        <h2 class="text-xl font-bold text-gray-900 tracking-tight">いきなり結論</h2>

        <p class="pb-10">
          量子コンピュータが従来のコンピュータに勝てる計算は、行列の掛け算です。めちゃくちゃでっかい、指数関数的に巨大な行列を、同じように巨大なベクトルに対してたった
          1 ステップで掛けることができます。
        </p>

        <p class="pb-10">
          <img src="https://i.gyazo.com/df274bb461ffcc268ecec69ab8cc670d.png" />
        </p>

        <p class="pb-10">
          行列の掛け算を知らなくても、行列計算が科学技術のいろんなところで活躍しているとなんとなく知っていれば、これはもの凄いことです。しかし落とし穴があります。
        </p>

        <ol class="list-decimal list-inside pb-10">
          <li>巨大なベクトルを入力するのが大変なこと</li>
          <li>使える行列に制限があること</li>
          <li>計算結果が一筋縄では取り出せないこと</li>
        </ol>

        <h2 class="text-xl font-bold text-gray-900 tracking-tight">1. 巨大なベクトルの入力</h2>

        <p class="pb-10">
          掛け算されるベクトルは、量子コンピュータの量子ビットの内容を「数の並び」として表したもので、量子コンピュータに入力してやる必要があります。たとえば、3
          ビットの量子コンピュータを持っている場合、入力するベクトルのデータは次のように数が 8
          個ならんだものとして表せます:
        </p>

        <p class="pb-10">
          $$\begin{bmatrix} 0.5 \\ 0 \\ 0 \\ 0.707 \\ 0 \\ 0 \\ 0.5 \\ 0 \end{bmatrix}$$
        </p>

        <p class="pb-10">
          一般に、\(n\) 個の量子ビットの内容は、数を 2 の \(n\) 乗個ならべたベクトルで表せます。
        </p>

        <p class="pb-10">
          ここでの問題は、n 個の量子ビットを持つ量子コンピュータにデータを入力するには、\(2^n\)
          個の数をセットする必要があることです。たとえば 100 量子ビットでは
        </p>

        <p class="pb-10">$$2^{100} = 1267650600228229401496703205376$$</p>

        <p class="pb-10">
          もの数をセットしなければならず、これには 1,000
          年単位の膨大な時間がかかってしまいます。唯一の希望は、まっさらな初期状態から始めて、量子コンピュータのいろんな命令を適用していくことによって、量子コンピュータ内で計算的に入力データを作ることです。それでもほとんど場合、合理的な時間では実行できません。
        </p>

        <h2 class="text-xl font-bold text-gray-900 tracking-tight">2. 使える行列の制限</h2>

        <p class="pb-10">
          ベクトルに掛けることのできる行列には、量子物理学に由来する 2 つの重要な制限があります。
        </p>

        <p class="pb-10">
          1 つめに、行列をかけるベクトルは常に、「2 乗長さの和が
          1」という性質を保つ必要があります。これはたとえば、先ほどの 3
          量子ビットで出てきたベクトル:
        </p>

        <p class="pb-10">
          $$\begin{bmatrix} 0.5 \\ 0 \\ 0 \\ 0.707 \\ 0 \\ 0 \\ 0.5 \\ 0 \end{bmatrix}$$
        </p>

        <p class="pb-10">について、2 乗長さの和をとると、</p>

        <p class="pb-10">
          $$ 0.5^2 + 0^2 + 0^2 + 0.707^2 + 0^2 + 0^2 + 0.5^2 + 0^2 = 0.25 + 0.5 + 0.25 = 1$$
        </p>

        <p class="pb-10">
          となり、たしかに 1
          となっています。そしてさらに、このベクトルに行列を掛けてできる新たなベクトルについても、同じ性質を保つ必要があります。
        </p>

        <p class="pb-10">
          2
          つめに、行列の掛け算はいつも、元に戻せる必要があります。つまり、ある行列を掛けるためには、それを元に戻すための行列がなくてはなりません。
        </p>

        <p class="pb-10">
          数学の用語では、これら 2
          つの性質を満たす行列を「ユニタリ行列」と呼びます。なぜこの制限が難しいのか、私が考えられる最も良い例えはルービックキューブです。キューブをばらばらにして組み直すことで、直接ゴールに到達できますがもちろんルール違反です。できるのは列を回転させることだけで、そこがチャレンジングな部分です。(ユニタリ行列も回転で構成されています)。
        </p>

        <h2 class="text-xl font-bold text-gray-900 tracking-tight">3. 計算結果の取り出し</h2>

        <p class="pb-10">
          量子コンピュータで計算した行列とベクトルの掛け算結果を直接読むことはできません。唯一できることは次の「計測」という命令だけです。たとえば、量子ビットの中身が次のベクトルになっているとします。
        </p>

        <p class="pb-10">
          $$\begin{bmatrix} 0 \\ 0.5 \\ 0 \\ 0 \\ 0.707 \\ 0 \\ 0.5 \\ 0 \end{bmatrix}$$
        </p>

        <p class="pb-10">
          ここで「計測」命令を行うと、それぞれの成分が 2 乗され、確率の \(\%\) として解釈されます。
        </p>

        <p class="pb-10">
          $$\begin{bmatrix} 0 \\ 25\% \\ 0 \\ 0 \\ 50\% \\ 0 \\ 25\% \\ 0 \end{bmatrix}$$
        </p>

        <p class="pb-10">
          そしてこの確率に従って、50% くらいの確率で、次のベクトルが出力されます。
        </p>

        <p class="pb-10">$$\begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}$$</p>

        <p class="pb-10">
          \(25\%\) の部分についても同様に、それぞれ確率 \(25\%\) でその成分だけを \(1\)
          とするベクトルが返ります。
        </p>

        <p class="pb-10">
          これは結局、何を意味するでしょうか?
          量子コンピュータで行列とベクトルの掛け算は、出力を決めるための確率 (重み)
          を計算しているだけなのです。さらには、計測した瞬間に元のベクトルはすべて破棄され、最終的には一番確率の大きい成分をだけを
          1 とするベクトルが返るだけです。
        </p>

        <h2 class="text-xl font-bold text-gray-900 tracking-tight">まとめ</h2>

        <p class="pb-10">
          量子コンピュータは巨大な行列とベクトルの掛け算を高速に行えます。しかし、入力データであるベクトルは巨大なため、計算的に作ることしかできません。そして、ベクトルに掛けることのできる行列、つまり量子コンピュータでできる操作は回転のみです。そして、掛け算の結果を直接読むことはできず、必ず計測を通して単純なベクトルしか読むことはできません。
        </p>

        <p class="pb-10">
          これらは非常に強い制約に見えますが、それでも、後に見る量子フーリエ変換 (QFT)
          はこれらの制約をうまく回避し、素因数分解などのアルゴリズムの一部として使うことで威力を発揮します。量子コンピュータのアルゴリズムを設計するには、これらの制約
          (特徴) を踏まえておく必要があります。
        </p>
      </div>
    </div>
  </body>
</html>
