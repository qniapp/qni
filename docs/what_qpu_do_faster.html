---
layout: page
title: QPU は何が得意？
description: 量子コンピュータの得意分野と制限
---

<div class="prose">
  <p>
    結局のところ、量子コンピュータ (QPU)
    は何が得意なのでしょうか。そしてさらに重要なことですが、メカニズム上の制限はあるのでしょうか。
  </p>

  <h2>いきなり結論</h2>

  <p>
    量子コンピュータが従来のコンピュータに勝てる計算は、行列の掛け算です。めちゃくちゃでっかい、指数関数的に巨大な行列を、同じように巨大なベクトルに対して、
    たった 1 ステップで掛けることができます。
  </p>

  <p>
    <img src="./images/matrix_multiplication.png" class="w-full md:w-2/3 h-auto md:mx-auto" />
  </p>

  <p>
    行列の掛け算を知らなくても、行列計算がゲームの 3D CG
    やスパコンなどの数値計算などで活躍しているとなんとなく知っていれば、その重要さが分かるでしょう。
    しかも行列の掛け算には大量の足し算と掛け算が含まれるので、それがたった 1
    ステップでできるという量子コンピュータの能力は驚くべきものです。しかし落とし穴もあります。
  </p>

  <ol class="list-decimal list-inside pb-10">
    <li>巨大なベクトルを入力するのが大変なこと</li>
    <li>使える行列に制限があること</li>
    <li>計算結果が一筋縄では取り出せないこと</li>
  </ol>

  <h2>1. 巨大なベクトルの入力</h2>

  <p>
    掛け算しようとするベクトルのデータは、当然ながら量子コンピュータに入力してやる必要があります。たとえば、3
    量子ビットの量子コンピュータを持っている場合、入力するベクトルのデータは次のように数が 8
    個ならんだものになります (一般に、\(n\) 個の量子ビットを持つマシンでは、数を 2 の \(n\)
    乗個ならべたベクトルへの掛け算を実行します)。
  </p>

  <p>$$\begin{bmatrix} 0.5 \\ 0 \\ 0 \\ 0.707 \\ 0 \\ 0 \\ 0.5 \\ 0 \end{bmatrix}$$</p>

  <p>
    ここでの問題は、値をセットしなければならないベクトルのサイズが \(2\) の \(n\)
    乗とまさに指数関数であることです。 たとえば 100 量子ビットでは
  </p>

  <p>$$2^{100} = 1267650600228229401496703205376$$</p>

  <p>
    もの数をセットしなければならず、これには 1,000
    年単位の膨大な時間がかかってしまいます。唯一の希望は、まっさらなベクトルの初期状態から始めて、量子コンピュータの中でいろんな行列を掛けていくことによって、計算的に入力データを作ることです。それでもほとんどの場合、合理的な時間では実行できません。
  </p>

  <h2>2. 使える行列の制限</h2>

  <p>
    量子コンピュータがベクトルに掛けることのできる行列には、量子力学に由来する 2
    つの重要な制限があります。
  </p>

  <p>
    1 つめに、掛け算するベクトルは常に「2 乗長さの和が
    1」という性質を保つ必要があります。これはたとえば、先ほどの 3 量子ビットで出てきたベクトル:
  </p>

  <p>$$\begin{bmatrix} 0.5 \\ 0 \\ 0 \\ 0.707 \\ 0 \\ 0 \\ 0.5 \\ 0 \end{bmatrix}$$</p>

  <p>について、2 乗長さの和をとると、</p>

  <p>$$ 0.5^2 + 0^2 + 0^2 + 0.707^2 + 0^2 + 0^2 + 0.5^2 + 0^2 = 0.25 + 0.5 + 0.25 = 1$$</p>

  <p>
    となり、たしかに 1
    となっています。そしてさらに、このベクトルに行列を掛けてできる新たなベクトルについても、同じ性質を保つ必要があります。
  </p>

  <p>
    2 つめに、行列の掛け算はいつも元に戻せる必要があります。つまり、ある行列 \(A\)
    を掛けたあとにやっぱり元に戻したくなった時、別の行列 \(B\)
    を掛けてやることでベクトルを元のデータに戻せる必要があります
    (行列の掛け算では、掛けたあと元に戻せない行列が数多くあります)。
  </p>

  <p>
    数学の用語では、これら 2 つの性質を満たす行列を「ユニタリ行列」と呼びます。
    なぜこの制限が難しいのか、私が考えられる最も良い例えはルービックキューブです。
    キューブをばらばらにして組み直すことで、直接的に色をそろえるのはルール違反です。
    できるのは列を回転させることだけで、そこがチャレンジングでみんなが夢中になる部分です。(ユニタリ行列も回転で構成されています)。
  </p>

  <h2>3. 計算結果の取り出し</h2>

  <p>
    ここがおそらく一番トリッキーな部分です。量子コンピュータで計算した行列とベクトルの掛け算結果を直接読むことはできません。唯一できることは次の「測定」という命令で出てくるベクトルを読むことだけです。たとえば、掛け算の結果が次のベクトルになっているとします。
  </p>

  <p>$$\begin{bmatrix} 0 \\ 0.5 \\ 0 \\ 0 \\ 0.707 \\ 0 \\ 0.5 \\ 0 \end{bmatrix}$$</p>

  <p>ここで「測定」命令を行うと、それぞれの成分が 2 乗され、確率 (\(\%\)) として解釈されます。</p>

  <p>
    $$\begin{bmatrix} 0\% \\ (0.5)^2 = 0.25 = 25\% \\ 0\% \\ 0\% \\ (0.707)^2 = 0.5 = 50\% \\ 0\% \\
    (0.5)^2 = 0.25 = 25\% \\ 0\% \end{bmatrix}$$
  </p>

  <p>そしてこの確率に従って、50% の確率で、その成分だけを 1 とする次のベクトルが出力されます。</p>

  <p>
    $$\begin{bmatrix} 0\% \\ 25\% \\ 0\% \\ 0\% \\ 50\% \\ 0\% \\ 25\% \\ 0\% \end{bmatrix}
    \longrightarrow \begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}$$
  </p>

  <p>
    または、確率 \(25\%\) でその成分だけを \(1\)
    とする次のいずれかのベクトルが返ります。ユーザが取り出せるのは、これらの \(0\) または \(1\)
    のみを持つベクトルだけです。
  </p>

  <p>
    $$\begin{bmatrix} 0\% \\ 25\% \\ 0\% \\ 0\% \\ 50\% \\ 0\% \\ 25\% \\ 0\% \end{bmatrix}
    \longrightarrow \begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}\ または\
    \begin{bmatrix} 0\% \\ 25\% \\ 0\% \\ 0\% \\ 50\% \\ 0\% \\ 25\% \\ 0\% \end{bmatrix}
    \longrightarrow \begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 1 \\ 0 \end{bmatrix}$$
  </p>

  <p>
    これは結局、何を意味するでしょうか?
    量子コンピュータで行列とベクトルの掛け算は、出力するベクトルを決める確率の<ruby
      ><rb>素</rb><rt>もと</rt></ruby
    >
    (重み、二乗すると確率になる数) を計算しているのです。
    しかも測定した瞬間に元のベクトルは破棄され、最終的には一番確率の大きい成分をだけを 1
    とするベクトルが返ります。 とても不思議な動作ですが、これは量子力学のルールに従ったものです。
  </p>

  <h2>まとめ</h2>

  <p>
    量子コンピュータは巨大な行列とベクトルの掛け算を高速に行えます。しかし、入力データであるベクトルは巨大なため、計算的に作ることしかできません。
    また、ベクトルに掛けることのできる行列は回転をあらわす特別な行列のみです。
    そして、掛け算の結果を直接読むことはできず、必ず測定を通して単純なベクトルしか読むことはできません。
  </p>

  <p>
    こんなに厳しいルールが課せられた上でも、うまく動作する量子アルゴリズムがいろいろと提案されています。
    たとえば後に見る量子フーリエ変換 (QFT)
    アルゴリズムは、量子因数分解などの中間処理として動作することで、ルールによる制約を回避し巧妙に動きます。
  </p>
</div>
