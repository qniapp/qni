---
layout: page
title: QPU は何が得意？
description: 量子コンピュータの得意分野と制限
---

<p class="pb-10">
  結局のところ、量子コンピュータ (QPU)
  は何が得意なのでしょうか。そしてさらに重要なことですが、メカニズム上の制限はあるのでしょうか。
</p>

<h2 class="text-xl font-bold text-gray-900 tracking-tight">いきなり結論</h2>

<p class="pb-10">
  量子コンピュータが従来のコンピュータに勝てる計算は、行列の掛け算です。めちゃくちゃでっかい、指数関数的に巨大な行列を、同じように巨大なベクトルに対して、
  たった 1 ステップでかけ算することができます。
</p>

<p class="pb-10">
  <img src="./images/matrix_multiplication.png" class="w-1/2 h-auto mx-auto" />
</p>

<p class="pb-10">
  行列の掛け算を知らなくても、行列計算がゲームの 3D CG
  やスパコンなどの数値計算などで活躍しているとなんとなく知っていれば、その重要さが分かるでしょう。
  しかも行列の掛け算には大量の足し算と掛け算が含まれるので、それがたった 1
  ステップでできるという量子コンピュータの性能は驚くべきものです。 しかし落とし穴もあります。
</p>

<ol class="list-decimal list-inside pb-10">
  <li>巨大なベクトルを入力するのが大変なこと</li>
  <li>使える行列に制限があること</li>
  <li>計算結果が一筋縄では取り出せないこと</li>
</ol>

<h2 class="text-xl font-bold text-gray-900 tracking-tight">1. 巨大なベクトルの入力</h2>

<p class="pb-10">
  掛け算しようとするベクトルのデータは、当然ながら量子コンピュータに入力してやる必要があります。たとえば、3
  量子ビットの量子コンピュータを持っている場合、入力するベクトルのデータは次のように数が 8
  個ならんだものになります (一般に、\(n\) 個の量子ビットを持つマシンでは、数を 2 の \(n\)
  乗個ならべたベクトルへの掛け算を実行します)。
</p>

<p class="pb-10">$$\begin{bmatrix} 0.5 \\ 0 \\ 0 \\ 0.707 \\ 0 \\ 0 \\ 0.5 \\ 0 \end{bmatrix}$$</p>

<p class="pb-10">
  ここでの問題は、値をセットしなければならないベクトルのサイズが \(2^n\)
  とまさに指数関数であることです。たとえば 100 量子ビットでは
</p>

<p class="pb-10">$$2^{100} = 1267650600228229401496703205376$$</p>

<p class="pb-10">
  もの数をセットしなければならず、これには 1,000
  年単位の膨大な時間がかかってしまいます。唯一の希望は、まっさらなベクトルの初期状態から始めて、量子コンピュータの中でいろんな行列を掛けていくことによって、計算的に入力データを作ることです。それでもほとんどの場合、合理的な時間では実行できません。
</p>

<h2 class="text-xl font-bold text-gray-900 tracking-tight">2. 使える行列の制限</h2>

<p class="pb-10">
  量子コンピュータがベクトルに掛けることのできる行列には、量子力学に由来する 2
  つの重要な制限があります。
</p>

<p class="pb-10">
  1 つめに、行列をかけるベクトルは常に、「2 乗長さの和が
  1」という性質を保つ必要があります。これはたとえば、先ほどの 3 量子ビットで出てきたベクトル:
</p>

<p class="pb-10">$$\begin{bmatrix} 0.5 \\ 0 \\ 0 \\ 0.707 \\ 0 \\ 0 \\ 0.5 \\ 0 \end{bmatrix}$$</p>

<p class="pb-10">について、2 乗長さの和をとると、</p>

<p class="pb-10">
  $$ 0.5^2 + 0^2 + 0^2 + 0.707^2 + 0^2 + 0^2 + 0.5^2 + 0^2 = 0.25 + 0.5 + 0.25 = 1$$
</p>

<p class="pb-10">
  となり、たしかに 1
  となっています。そしてさらに、このベクトルに行列を掛けてできる新たなベクトルについても、同じ性質を保つ必要があります。
</p>

<p class="pb-10">
  2 つめに、行列の掛け算はいつも、元に戻せる必要があります。つまり、ある行列 \(A\)
  を掛けたあとにやっぱり元に戻したくなった時、別の行列 \(B\)
  を掛けてやることでベクトルを元のデータに戻せる必要があります
  (行列の掛け算では、掛けたあと元に戻せない行列がほとんどです)。
</p>

<p class="pb-10">
  数学の用語では、これら 2 つの性質を満たす行列を「ユニタリ行列」と呼びます。
  なぜこの制限が難しいのか、私が考えられる最も良い例えはルービックキューブです。
  キューブをばらばらにして組み直すことで、直接的に色をそろえるのはルール違反です。
  できるのは、列を回転させることだけで、そこがチャレンジングな部分です。(ユニタリ行列も回転で構成されています)。
</p>

<h2 class="text-xl font-bold text-gray-900 tracking-tight">3. 計算結果の取り出し</h2>

<p class="pb-10">
  ここが一番トリッキーな部分です。量子コンピュータで計算した行列とベクトルの掛け算結果を直接読むことはできません。唯一できることは次の「計測」という命令で出てくるベクトルを読むことだけです。たとえば、掛け算の結果が次のベクトルになっているとします。
</p>

<p class="pb-10">$$\begin{bmatrix} 0 \\ 0.5 \\ 0 \\ 0 \\ 0.707 \\ 0 \\ 0.5 \\ 0 \end{bmatrix}$$</p>

<p class="pb-10">
  ここで「計測」命令を行うと、それぞれの成分が 2 乗され、確率 (\(\%\)) として解釈されます。
</p>

<p class="pb-10">
  $$\begin{bmatrix} 0\% \\ (0.5)^2 = 0.25 = 25\% \\ 0\% \\ 0\% \\ (0.707)^2 = 0.5 = 50\% \\ 0\% \\
  (0.5)^2 = 0.25 = 25\% \\ 0\% \end{bmatrix}$$
</p>

<p class="pb-10">
  そしてこの確率に従って、50% の確率で、その成分だけを 1 とする次のベクトルが出力されます。
</p>

<p class="pb-10">
  $$\begin{bmatrix} 0\% \\ 25\% \\ 0\% \\ 0\% \\ 50\% \\ 0\% \\ 25\% \\ 0\% \end{bmatrix}
  \longrightarrow \begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}$$
</p>

<p class="pb-10">
  または、確率 \(25\%\) でその成分だけを \(1\)
  とする次のいずれかのベクトルが返ります。ユーザが取り出せるのは、これらの \(0\) または \(1\)
  のみを持つベクトルだけです。
</p>

<p class="pb-10">
  $$\begin{bmatrix} 0\% \\ 25\% \\ 0\% \\ 0\% \\ 50\% \\ 0\% \\ 25\% \\ 0\% \end{bmatrix}
  \longrightarrow \begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}\ または\
  \begin{bmatrix} 0\% \\ 25\% \\ 0\% \\ 0\% \\ 50\% \\ 0\% \\ 25\% \\ 0\% \end{bmatrix}
  \longrightarrow \begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 1 \\ 0 \end{bmatrix}$$
</p>

<p class="pb-10">
  これは結局、何を意味するでしょうか?
  量子コンピュータで行列とベクトルの掛け算は、出力するベクトルを決める確率の<ruby
    ><rb>素</rb><rt>もと</rt></ruby
  >
  (重み、二乗すると確率になる数) を計算しているのです。
  しかも計測した瞬間に元のベクトルは破棄され、最終的には一番確率の大きい成分をだけを 1
  とするベクトルが返ります。 とても不思議な動作ですが、すべて量子力学のルールに従ったものです。
</p>

<h2 class="text-xl font-bold text-gray-900 tracking-tight">まとめ</h2>

<p class="pb-10">
  量子コンピュータは巨大な行列とベクトルの掛け算を高速に行えます。しかし、入力データであるベクトルは巨大なため、計算的に作ることしかできません。
  また、ベクトルに掛けることのできる行列は回転をあらわす特殊な行列のみです。
  そして、掛け算の結果を直接読むことはできず、必ず計測を通して単純なベクトルしか読むことはできません。
</p>

<p class="pb-10">
  こんなに厳しいルールが課せられた上でも、後に見る量子フーリエ変換 (QFT)
  アルゴリズムは素因数分解アルゴリズムなどの一部として非常に巧妙に動きます。
  また今回は「行列」「ベクトル」などの数学的な用語が登場しましたが、Qni
  はこれらをすべてうまく視覚化しますので心配はいりません。
</p>
